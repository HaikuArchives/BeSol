//Jason Wrinkle - Solitaire Game 
//Copyright (C) 1999  Jason Wrinkle (jwrinkle@utdallas.edu)
//
//This program is free software; you can redistribute it and/or 
//modify it under the terms of the GNU General Public License 
//as published by the Free Software Foundation; either version 2 
//of the License, or (at your option) any later version. 
//
//This program is distributed in the hope that it will be useful, 
//but WITHOUT ANY WARRANTY; without even the implied warranty of 
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
//GNU General Public License for more details. 
//
//You should have received a copy of the GNU General Public License 
//along with this program; if not, write to the Free Software 
//Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 


// BesolWindow.cpp
// Generated by Interface Elements (Window v2.3) on Feb 19 1999
// This is a user written class and will not be overwritten.

#include "BesolWindow.h"

BesolWindow::BesolWindow(void) : IEWindow("besol_window"), layoutfile(NULL), gamefile(NULL)
{	
	Show();
	Lock();
	Unlock();
	popmenu = new BPopUpMenu("Pile Pop-up");
	BMenuItem* item = new BMenuItem("New Pile", new BMessage(NEW_PILE)); 
	item->SetTarget(be_app);
	popmenu->AddItem(item);
	Show();		
};

BesolWindow::~BesolWindow(void)
{};

bool BesolWindow::QuitRequested()
{
	be_app->PostMessage(B_QUIT_REQUESTED); 
  	return true; 	
};

// Handling of user interface and other events
void BesolWindow::MessageReceived(BMessage *message)
{
	switch(message->what)
	{
		case B_MOUSE_DOWN:
		{
			MouseDown(BPoint(0, 0));
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_GAME_NEW:    // "New" is selected from menu…
		{
			be_app->PostMessage(message);
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_GAME_OPEN___:    // "Open…" is selected from menu…
		{
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_GAME_SAVE)->SetEnabled(true);		// "save Current Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_GAME_SAVE_AS___)->SetEnabled(true);		// "save as Current Layout"

			message->what = GAME_OPENREF_RECEIVED;
			message->AddString("subdir", "./saved_games");		
			getfile(message, true, false);
			break;
		};
		case GAME_OPENREF_RECEIVED:
		{
			status_t errcode;

			entry_ref gameref;
			errcode = message->FindRef("refs", &gameref);
			if (gamefile == NULL) gamefile = new BFile(&gameref, B_READ_WRITE);
			else gamefile->SetTo(&gameref, B_READ_WRITE);
			
			gamefile->Seek(0, SEEK_SET);
			message->MakeEmpty();
			errcode = message->Unflatten(gamefile);

			if (Open_Game(message))
			{
//FEATURE: add name of saved game to title bar in addition to name of game type
//				char* newwintitle = NULL;
//				newwintitle = mystrconcat("Card Games - ", layoutref.name);
//				SetTitle(newwintitle);
			};
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_GAME_SAVE:    // "Save" is selected from menu…
		{
			if ( (gamefile != NULL) && (gamefile->InitCheck() == B_OK) ) Save_Game(message);
			else 
			{
				message->what = IE_BESOLWINDOW_SOLMENU_GAME_SAVE_AS___;
				MessageReceived (message);
			};
			break;
		};
		case GAME_SAVEREF_RECEIVED:
		{
			const char* filename;
			entry_ref fileref;
			message->FindString("name", &filename);
			message->FindRef("directory", &fileref);

//FEATURE: add name of saved game to title bar in addition to name of game type
//			char* newwintitle = NULL;
//			newwintitle = mystrconcat("Card Games - ", filename);
//			SetTitle(newwintitle);

			BDirectory savedir (&fileref);
			gamefile = new BFile(&savedir, filename, B_CREATE_FILE|B_READ_WRITE);			
			Save_Game(message);
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_GAME_SAVE_AS___:    // "Save As…" is selected from menu…
		{
			message->what = GAME_SAVEREF_RECEIVED;
			message->AddString("subdir", "./saved_games");		
			getfile(message, false, false);
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_LAYOUT:    // "Edit Current Layout" is selected from menu…
		case IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_RULES:    // "Edit Current Rules" is selected from menu…
		{			
			bool editmode = !(KeyMenuBar()->FindItem(message->what)->IsMarked());
			KeyMenuBar()->FindItem(message->what)->SetMarked(editmode);		// "Edit Current Layout/Rules"

			if (message->what == IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_RULES)
				KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_LAYOUT)->SetEnabled(!editmode);		// "Edit Current Layout/Rules"
			else	
				KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_RULES)->SetEnabled(!editmode);		// "Edit Current Layout/Rules"
			
			bool deckloaded = KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_OPTIONS_LOAD_DECK___)->IsMarked();		// "load deck"

			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_GAME_NEW)->SetEnabled((!editmode) && (deckloaded));		// "new game"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_NEW)->SetEnabled(!editmode);		// "new Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_OPEN___)->SetEnabled(!editmode);		// "open Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE)->SetEnabled(!editmode);		// "save Current Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE_AS___)->SetEnabled(!editmode);		// "saveas Current Layout"

			message->AddBool("editmode", editmode);
			be_app->PostMessage(message);

			break;
		};
		case IE_BESOLWINDOW_SOLMENU_EDIT_UNDO:    // "Undo" is selected from menu…
			break;

		case IE_BESOLWINDOW_SOLMENU_EDIT_CUT:    // "Cut" is selected from menu…
			break;

		case IE_BESOLWINDOW_SOLMENU_EDIT_COPY:    // "Copy" is selected from menu…
			break;

		case IE_BESOLWINDOW_SOLMENU_EDIT_PASTE:    // "Paste" is selected from menu…
			break;

		case IE_BESOLWINDOW_SOLMENU_LAYOUT_NEW:    // "New" is selected from menu…
		{
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE_AS___)->SetEnabled(false);		// "saveas Current Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE)->SetEnabled(false);		// "save Current Layout"

			Clear();
			if (layoutfile != NULL) layoutfile->Unset();
			SetTitle("Card Games - No layout loaded");
			break;
		};
		case LAYOUT_OPENREF_RECEIVED:
		{
			status_t errcode;

			entry_ref layoutref;
			errcode = message->FindRef("refs", &layoutref);
			if (layoutfile == NULL) layoutfile = new BFile(&layoutref, B_READ_WRITE);
			else layoutfile->SetTo(&layoutref, B_READ_WRITE);
			
			layoutfile->Seek(0, SEEK_SET);
			message->MakeEmpty();
			errcode = message->Unflatten(layoutfile);

			if (Open_Layout(message))
			{
				char* newwintitle = NULL;
				newwintitle = mystrconcat("Card Games - ", layoutref.name);
				SetTitle(newwintitle);
			};
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_LAYOUT_OPEN___:    // "Open..." is selected from menu…
		{
			message->what = LAYOUT_OPENREF_RECEIVED;
			message->AddString("subdir", "./games");		
			getfile(message, true, false);					
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE:    // "Save" is selected from menu…
		{
			if ((layoutfile != NULL) && (layoutfile->InitCheck() == B_OK)) Save_Layout(message);
			else 
			{
				message->what = IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE_AS___;
				MessageReceived (message);
			};
			break;
		};
		case LAYOUT_SAVEREF_RECEIVED:
		{
			const char* filename;
			entry_ref fileref;
			message->FindString("name", &filename);
			message->FindRef("directory", &fileref);

			char* newwintitle = NULL;
			newwintitle = mystrconcat("Card Games - ", filename);
			SetTitle(newwintitle);

			BDirectory savedir (&fileref);
			layoutfile = new BFile(&savedir, filename, B_CREATE_FILE|B_READ_WRITE);
			
			Save_Layout(message);
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_LAYOUT_SAVE_AS___:    // "Save As..." is selected from menu…
		{
			message->what = LAYOUT_SAVEREF_RECEIVED;
			message->AddString("subdir", "./games");		
			getfile(message, false, false);
			break;
		};
		case IE_BESOLWINDOW_SOLMENU_OPTIONS_LOAD_DECK___:    // "Load Deck..." is selected from menu…
		{
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_OPTIONS_LOAD_DECK___)->SetMarked(true);		// "load deck Layout"

			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_OPEN___)->SetEnabled(true);		// "open Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_LAYOUT_NEW)->SetEnabled(true);		// "new Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_LAYOUT)->SetEnabled(true);		// "Edit Layout"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_RULES)->SetEnabled(true);		// "edit rules"
			KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_GAME_NEW)->SetEnabled(true);		// "new game"

			message->what = DECK_REF_RECEIVED;
			message->AddString("subdir", "./decks");		
			getfile(message, true, true);
			break;
		};
		case NEW_PILE: 
		{
//may be able to take out this pass... look into it (POP-UP Menus)
			be_app->PostMessage(message);
			break;
		};
		case MOVE_PILE:
		{
			void* temp;
			BView* pile;
			uint32 buttons;			
			BPoint location;
			ChildAt(2)->GetMouse(&location, &buttons, false);

			message->FindPointer("pile", &temp);
			pile = static_cast<BView*>(temp);
			pile->MoveTo(location);
			pile->Show();
			break;
		};
		default:
		{
			inherited::MessageReceived(message);
			break;
		};
	}

}


// Update the menu items before they appear on screen
void BesolWindow::MenusBeginning()
{
	KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_GAME_ABOUT___)->SetTarget(be_app);		// "About…"
	KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_GAME_QUIT)->SetTarget(be_app);		// "Quit"
}

void BesolWindow::Save_Game(BMessage* game)
{//to be implemented further... doesn't save cards... same functionality as save layout right now
	if (game == NULL) game = new BMessage(GAME_SAVE);
	else 
	{
		game->MakeEmpty();
		game->what = GAME_SAVE;
	};
	
	BView* playfield = ChildAt(2);
	int16 lastkid = playfield->CountChildren();
	game->AddInt16("numpiles", lastkid);
	
	while (lastkid > 0)
	{
		playfield->ChildAt(--lastkid)->MessageReceived(game);
	};
	
	gamefile->Seek(0, SEEK_SET);	
	status_t errcode = game->Flatten(gamefile);
	if (errcode != B_OK) beep(); 				
};

bool BesolWindow::Open_Game(BMessage* game)
{//to be implemented (save fcn as open layout i think)
	Clear();
	BView* playfield = ChildAt(2);
	BView* pile = NULL;
	BMessage pilearchive;
	int16 numpiles;
	BArchivable* unarchived = NULL;
	game->FindInt16("numpiles", &numpiles);
	for (int16 i = 0;  i < numpiles; i++){
		game->FindMessage("Pile", i, &pilearchive);
		unarchived = instantiate_object (&pilearchive);
		pilearchive.MakeEmpty();
		if (unarchived != NULL) {

			pile = cast_as (unarchived, BView);
			playfield->AddChild(pile);
			pile->Show();			
			unarchived = NULL;
		};
	};

	return true;
};

void BesolWindow::Clear()
{
	BView* playfield = ChildAt(2);
	BView* pile;
	int lastkid = playfield->CountChildren();
	while (lastkid > 0)
	{
		pile = playfield->ChildAt(0);
		playfield->RemoveChild(pile);
		delete pile;
		lastkid--;
	};
};

bool BesolWindow::Open_Layout(BMessage* layout)
{
	Clear();
	BView* playfield = ChildAt(2);
	BView* pile = NULL;
	BMessage pilearchive;
	int16 numpiles;
	BArchivable* unarchived = NULL;
	layout->FindInt16("numpiles", &numpiles);
	for (int16 i = 0;  i < numpiles; i++){
		layout->FindMessage("Pile", i, &pilearchive);
		unarchived = instantiate_object (&pilearchive);
		pilearchive.MakeEmpty();
		if (unarchived != NULL) {

			pile = cast_as (unarchived, BView);
			playfield->AddChild(pile);
			pile->Show();			
			unarchived = NULL;
		};
	};
	
	layout->what = RULES_LOAD;
	if (numpiles > 0) playfield->ChildAt(0)->MessageReceived(layout);
	
	return true;
};

void BesolWindow::DispatchMessage(BMessage* message, BHandler* handler)
{
	if ( (message->what == B_MOUSE_DOWN) && (KeyMenuBar()->FindItem(IE_BESOLWINDOW_SOLMENU_EDIT_EDIT_CURRENT_LAYOUT)->IsMarked()) )
	{
		BView* playfield = ChildAt(2);
		BPoint location;
		uint32 buttons;
		playfield->GetMouse(&location, &buttons, false);
		int index = 0;
		bool pilecaught = false;
		int numkids = playfield->CountChildren();
		
		while ((index < numkids) && (!pilecaught))
		{
			pilecaught = playfield->ChildAt(index)->Frame().Contains(location);
			index++;
		}; 
		
		if (!pilecaught) MouseDown(location);		
	};
	IEWindow::DispatchMessage(message, handler);
};

void BesolWindow::MouseDown(BPoint location)
{
	BPoint cursor;
	uint32 buttons;
	BView* playfield = ChildAt(2);
	playfield->GetMouse(&cursor, &buttons, false);

	if (buttons == B_SECONDARY_MOUSE_BUTTON)
	{
		BMenuItem* selected = NULL;
		
		playfield->ConvertToScreen(&location);
		selected = popmenu->Go(location, false);
		playfield->ConvertFromScreen(&location);

		if (selected) 
		{
			BMessage* response = new BMessage(selected->Message()->what);
			response->AddPointer("pile props", NULL);
			response->AddPoint("location", location);//playfield coords
			PostMessage(response);
		};
	};	
};

void BesolWindow::Save_Layout(BMessage* layout)
{
	BView* playfield = ChildAt(2);
	int16 numkids = playfield->CountChildren();

	if (layout == NULL) layout = new BMessage(RULES_SAVE);
	else 
	{
		layout->MakeEmpty();
		layout->what = RULES_SAVE;
	};
	layout->AddInt16("numpiles", numkids);
	if (numkids > 0) playfield->ChildAt(0)->MessageReceived(layout);
	
	
	layout->what = LAYOUT_SAVE;
	for (int i = 0; i < numkids; i++)
		playfield->ChildAt(i)->MessageReceived(layout);
		
	layoutfile->Seek(0, SEEK_SET);	
	status_t errcode = layout->Flatten(layoutfile);
	if (errcode != B_OK) beep(); 				
};

void BesolWindow::getfile(BMessage* message, bool open, bool to_be_app)
{
	static BFilePanel* filepanel = NULL;
	if (filepanel != NULL) delete filepanel;// this might enable a bug... user may not have made first selection yet... also not elegant... need to change props instead of recreating
	if (open) filepanel = new BFilePanel(B_OPEN_PANEL);
	else filepanel = new BFilePanel(B_SAVE_PANEL);
	
	if (to_be_app) filepanel->SetTarget(be_app);
	else filepanel->SetTarget(this);

	char* subdir;
	message->FindString("subdir", (const char**) &subdir);
	app_info info;
	be_app->GetAppInfo(&info);
	BEntry infoentry(&info.ref);
	BEntry dirtemp;
	infoentry.GetParent(&dirtemp);
	BDirectory appdir(&dirtemp);
	appdir.FindEntry(subdir, &dirtemp);
	filepanel->SetPanelDirectory(&dirtemp);

	filepanel->SetMessage(message);

	filepanel->Show();
};