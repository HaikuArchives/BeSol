//Jason Wrinkle - Solitaire Game 
//Copyright (C) 1999  Jason Wrinkle (jwrinkle@utdallas.edu)
//
//This program is free software; you can redistribute it and/or 
//modify it under the terms of the GNU General Public License 
//as published by the Free Software Foundation; either version 2 
//of the License, or (at your option) any later version. 
//
//This program is distributed in the hope that it will be useful, 
//but WITHOUT ANY WARRANTY; without even the implied warranty of 
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
//GNU General Public License for more details. 
//
//You should have received a copy of the GNU General Public License 
//along with this program; if not, write to the Free Software 
//Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 


// TransmissionRuleEditor.cpp
// Generated by Interface Elements (Window v2.3) on Mar 12 1999
// This is a user written class and will not be overwritten.

#include "TransmissionRuleEditor.h"

TransmissionRuleEditor::TransmissionRuleEditor(void)
	: IEWindow("Transmission Rule Editor"), makesym(true)
{
	BMenuField* menu;
	BMenuItem* menuitem;
	BMessage* msg;		

	menu = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
	msg = new BMessage(IE_TRANSMISSIONRULEEDITOR_PILEORDERINGVALUESTEPS_TOGGLE_ALL);
	menuitem = menu->Menu()->FindItem(IE_TRANSMISSIONRULEEDITOR_PILEORDERINGVALUESTEPS_TOGGLE_ALL);
	menuitem->SetMessage(msg);
	menuitem->SetEnabled(true);

	menu = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
	msg = new BMessage(IE_TRANSMISSIONRULEEDITOR_PILEORDERINGSUITSTEPS_TOGGLE_ALL);
	menuitem = menu->Menu()->FindItem(IE_TRANSMISSIONRULEEDITOR_PILEORDERINGSUITSTEPS_TOGGLE_ALL);
	menuitem->SetMessage(msg);
	menuitem->SetEnabled(true);

	current_rules = new TRANSRULES();
	Reset();
};


TransmissionRuleEditor::~TransmissionRuleEditor(void)
{
}

void TransmissionRuleEditor::Set_Target(BView* trgt)
{
	target = trgt;
};

void TransmissionRuleEditor::CleanUp()
{
	BMenuField* menufield;
	BMenuItem* item;
	int numitems;

	targetrulest.clear();
	targetrulesf.clear();

	menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
	numitems = menufield->Menu()->CountItems() - 1;
	for (; numitems >= 0; numitems--)
	{
		item = menufield->Menu()->RemoveItem(numitems);
		delete item;
	};

	menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
	numitems = menufield->Menu()->CountItems() - 1;
	for (; numitems >= 0; numitems--)
	{
		item = menufield->Menu()->RemoveItem(numitems);
		delete item;
	};


	target = NULL;
			
	list<char*>::iterator striter1 = IDstrings.begin(), striter2 = striter1;
	char* tempstr;
	while (striter1 != IDstrings.end())
	{
		tempstr = *striter1;
		striter2++;
		IDstrings.remove(*striter1);
		striter1 = striter2;
		delete[] tempstr;
	};
	
	Lock();
	BView* checkview = FindView("check view");
	BCheckBox* tempcheckbox;
	int numkids = checkview->CountChildren();
	while (numkids > 0)
	{
		tempcheckbox = static_cast<BCheckBox*> (checkview->ChildAt(0));
		checkview->RemoveChild(tempcheckbox);
		delete tempcheckbox;
		numkids--;
	};
	Unlock();
};

void TransmissionRuleEditor::Reset()
{
	Lock();
	
	BTextControl* temptxt = NULL;
	BCheckBox* tempchk = NULL;
	BRadioButton* tempradbut = NULL;
	BMenuField* menufield = NULL;
	
	tempchk = static_cast <BCheckBox*> (FindView("Enable Transmission"));
	tempchk->SetValue(current_rules->enable);

	temptxt = static_cast <BTextControl*> (FindView("allowed # - min"));
	temptxt->SetText( Int32ToStr(current_rules->mincards) );

	temptxt = static_cast <BTextControl*> (FindView("allowed # - max"));
	temptxt->SetText( Int32ToStr(current_rules->maxcards) );
	
	bool enablesnappable = false;
	switch (current_rules->behavior)
	{
		case BLOCK_DRAG:
		{
			tempradbut = static_cast <BRadioButton*> (FindView("Ordering - Block"));
			enablesnappable = false;
			break;
		};
		case UF_MESSY_DRAG:
		{
			tempchk = static_cast <BCheckBox*> (FindView("Ordering - UF Messy"));
			tempchk->SetValue(true);			
		//don't want a break here!
		};
		case UF_CLEAN_DRAG:
		{
			enablesnappable = true;
			tempradbut = static_cast <BRadioButton*> (FindView("Ordering - UF Clean"));
			break;
		};
	};
	tempchk = static_cast <BCheckBox*> (FindView("Ordering - UF Messy"));
	tempchk->SetEnabled(enablesnappable);			
	if (tempradbut && tempradbut->IsEnabled()) tempradbut->SetValue(1);
	else beep();

	switch (current_rules->orderingtype)
	{
		case ORDERINGNONE:	// 'Ordering - None' is pressed...
			tempradbut = static_cast <BRadioButton*> (FindView("Ordering - None"));
		case ORDERINGSEND:	// 'Ordering - sender' is pressed...
			if (current_rules->orderingtype == ORDERINGSEND)
				tempradbut = static_cast <BRadioButton*> (FindView("Ordering - sender"));
		case ORDERINGRECV:	// 'Ordering - receiver' is pressed...
			if (current_rules->orderingtype == ORDERINGRECV)
				tempradbut = static_cast <BRadioButton*> (FindView("Ordering - receiver"));

			tempchk = static_cast <BCheckBox*> (FindView("cycle suits"));
			tempchk->SetEnabled(false);
	
			tempchk = static_cast <BCheckBox*> (FindView("cycle values"));
			tempchk->SetEnabled(false);
									
			menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
			menufield->SetEnabled(false);
	
			menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
			menufield->SetEnabled(false);
			break;
		case ORDERINGSOME:
		{
			tempradbut = static_cast <BRadioButton*> (FindView("Ordering - Some"));
			
			tempchk = static_cast <BCheckBox*> (FindView("cycle suits"));
			tempchk->SetEnabled(true);
			tempchk->SetValue(current_rules->ordering->cyclesuits);
			
			tempchk = static_cast <BCheckBox*> (FindView("cycle values"));
			tempchk->SetEnabled(true);
			tempchk->SetValue(current_rules->ordering->cyclevalues);		
									
			list<int32>::iterator iter;
			int numitems;
		
			menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
			menufield->SetEnabled(true);
			numitems = menufield->Menu()->CountItems();
			
			for (int i = 0; i < numitems; i++) menufield->Menu()->ItemAt(i)->SetMarked(false);
			
			iter = current_rules->ordering->suitsteps.begin();
			while (iter != current_rules->ordering->suitsteps.end())
			{
				menufield->Menu()->FindItem(Int32ToStr(*iter++))->SetMarked(true);
			};
	
			menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
			menufield->SetEnabled(true);
			numitems = menufield->Menu()->CountItems();
			
			for (int i = 0; i < numitems; i++) menufield->Menu()->ItemAt(i)->SetMarked(false);
			
			iter = current_rules->ordering->valuesteps.begin();
			while (iter != current_rules->ordering->valuesteps.end())
			{
				menufield->Menu()->FindItem(Int32ToStr(*iter++))->SetMarked(true);
			};
			break;
		};
	};
	tempradbut->SetValue(1);

	Unlock();
};

// Handling of user interface and other events
void TransmissionRuleEditor::MessageReceived(BMessage *message)
{
	switch(message->what)
	{
		case IE_TRANSMISSIONRULEEDITOR_PILEORDERINGSUITSTEPS_TOGGLE_ALL:
		case IE_TRANSMISSIONRULEEDITOR_PILEORDERINGVALUESTEPS_TOGGLE_ALL:
		{
			BMenuField* menufield;
			char* label;
			if (message->what == IE_TRANSMISSIONRULEEDITOR_PILEORDERINGVALUESTEPS_TOGGLE_ALL)
			{
				message->what = VALUE_STEPS_CHANGED;
				menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
				label = "value step";
			}
			else
			{
				message->what = SUIT_STEPS_CHANGED;
				menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
				label = "suit step";
			};
			
			int32 maxitemindex = (menufield->Menu()->CountItems() - 1 - 2)/2;
			
			message->AddInt32 (label, 0);
			for (int32 i = -maxitemindex; i <= maxitemindex; i++)
			{
				message->ReplaceInt32(label, i);
				MessageReceived(message);
			}; 
			break;
		};
		case SUIT_STEPS_CHANGED:
		{
			int32 stepping = 0;
			bool stepstate;
			message->FindInt32 ("suit step", &stepping);
			BMenuField* menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
			BMenuItem* menuitem = menufield->Menu()->FindItem(IntToStr(stepping));
			
			stepstate = menuitem->IsMarked();
			if (stepstate) current_rules->ordering->suitsteps.remove(stepping);
			else current_rules->ordering->suitsteps.push_back(stepping);
			
			menuitem->SetMarked(!stepstate);
			break;
		};
		case VALUE_STEPS_CHANGED:
		{
			int32 stepping = 0;
			bool stepstate;
			message->FindInt32 ("value step", &stepping);
			BMenuField* menufield = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
			BMenuItem* menuitem = menufield->Menu()->FindItem(IntToStr(stepping));
			
			stepstate = menuitem->IsMarked();
			if (stepstate) current_rules->ordering->valuesteps.remove(stepping);
			else current_rules->ordering->valuesteps.push_back(stepping);
			
			menuitem->SetMarked(!stepstate);
			break;
		};
		case RULES_REQUEST:
		{
			BMessage* tempmsg = new BMessage();
			status_t errcode = message->FindMessage("rules", tempmsg);
			if (errcode == B_OK) 
			{	
				current_rules->UnEncapsulate(tempmsg);
				Reset();
			};
			break;
		};
		case LAYOUT_DATA:
		{		
			deck_info* dinfo = new deck_info;
			ssize_t numbytes;
			message->FindData("deck info", 'DkDt', (const void**) &(dinfo), &numbytes);
			BMenuItem* item;
			BMenuField* menu;
			BMessage* msg;

			menu = static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"));
			for (int i = dinfo->num_suits - 1; i > 0; i--)
			{
				msg = new BMessage(SUIT_STEPS_CHANGED);			
				msg->AddInt32("suit step", -i);
				item = new BMenuItem(Int32ToStr(-i), msg);
				menu->Menu()->AddItem(item);
			};
			for (int i = 0; i < dinfo->num_suits; i++)
			{
				msg = new BMessage(SUIT_STEPS_CHANGED);			
				msg->AddInt32("suit step", i);
				item = new BMenuItem(Int32ToStr(i), msg);
				menu->Menu()->AddItem(item);
			};

			menu = static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"));
			for (int i = dinfo->num_values - 1; i > 0; i--)
			{
 				msg = new BMessage(VALUE_STEPS_CHANGED);			
				msg->AddInt32("value step", -i);
				item = new BMenuItem(Int32ToStr(-i), msg);
				menu->Menu()->AddItem(item);
			};
			for (int i = 0; i < dinfo->num_values; i++)
			{
 				msg = new BMessage(VALUE_STEPS_CHANGED);			
				msg->AddInt32("value step", i);
				item = new BMenuItem(Int32ToStr(i), msg);
				menu->Menu()->AddItem(item);
			};


			char* tempstr;
			int index = 0;
			status_t errcode = B_OK;

			errcode = message->FindString("IDstring", index++, (const char**) &tempstr);
			while (errcode == B_OK)
			{
				IDstrings.push_back(mystrconcat(tempstr, ""));
				errcode = message->FindString("IDstring", index++, (const char**) &tempstr);
			};
			int numstr = index - 1;
						
//update all instances of IDstrings
			BCheckBox* checkbox;
			BView* checkview;
			BStringView* nameview;
			list<char*>::const_iterator tostringiter, fromstringiter;		
			
			Lock();

			checkview = FindView("check view");
			BRect tonameframe = checkview->Bounds();
			tonameframe.right = tonameframe.left + 50;
			tonameframe.top += 5;
			tonameframe.bottom = tonameframe.top + 12;
			BRect fromnameframe(tonameframe.right, 0, tonameframe.right + tonameframe.Height() + 10, tonameframe.Width());
			tonameframe.OffsetBy(0, fromnameframe.Height());

			BRect chkframe ( tonameframe.RightTop(), BPoint(tonameframe.right + 12, tonameframe.bottom) );

			tostringiter = IDstrings.begin();
			for (int32 t = 0; t < numstr; t++)
			{
				tempstr = mystrconcat(*tostringiter, "");
				nameview = new BStringView(tonameframe, "", tempstr);
				nameview->SetAlignment(B_ALIGN_RIGHT);
				checkview->AddChild(nameview);
				
				fromstringiter = IDstrings.begin();
				for (int32 f = 0; f < numstr; f++)
				{
					if (t == 0)
					{
						tempstr = mystrconcat(*fromstringiter, "");
						nameview = new BStringView(fromnameframe, "", tempstr);
						BFont* newfont = new BFont();
						nameview->GetFont(newfont);
//rotation is messed up... a 90 degree rotation rotates font out of view (mostly) need to change base line position somehow
						newfont->SetRotation(70);
						nameview->SetFont(newfont);
						checkview->AddChild(nameview);						
						fromnameframe.OffsetTo (fromnameframe.left + 12 + 2, (float) 0);
					};
					
					checkbox = new BCheckBox(chkframe, "checkbox", "", NULL);
//					if (t > f) checkbox->SetViewColor (255, 0, 0, 0);//tried to create an obvious symmetry line for symmetric rules, didn't work as easily as I wanted though
//					else checkbox->SetViewColor (0, 0, 255, 0);
					msg = new BMessage(TRANS_BOX_CHECKED);
		 			msg->AddInt32("to", t);
					msg->AddInt32("from", f);
					msg->AddPointer("checkbox", checkbox);
					checkbox->SetMessage(msg);
					
					checkview->AddChild (checkbox);
					chkframe.OffsetBy(chkframe.Width() + 2, (float)0);
					
					fromstringiter++;
				};
				tonameframe.OffsetTo((float) 0, tonameframe.bottom  + 2);
				chkframe.OffsetTo(tonameframe.RightTop());
				
				tostringiter++;
			};
					
			Unlock();
			
			break;
		};
		case IE_TRANSMISSIONRULEEDITOR_ENABLETRANSMISSION:	// 'Enable Transmission' is pressed...
			current_rules->enable = (static_cast <BControl*> (FindView("Enable Transmission"))->Value()); 
			break;

		case IE_TRANSMISSIONRULEEDITOR_ALLOWEDMIN:	// 'allowed # - min' modified...
		{
			BTextControl* textcontrol;
			textcontrol = static_cast <BTextControl*> (FindView("allowed # - min"));
			current_rules->mincards = atoi(textcontrol->Text());	
			break;
		};
		case IE_TRANSMISSIONRULEEDITOR_ALLOWEDMAX:	// 'allowed # - max' modified...
		{
			BTextControl* textcontrol;
			textcontrol = static_cast <BTextControl*> (FindView("allowed # - max"));
			current_rules->maxcards = atoi(textcontrol->Text());	
			break;
		};
		case IE_TRANSMISSIONRULEEDITOR_ORDERINGNONE:	// 'Ordering - None' is pressed...
			static_cast <BControl*> (FindView("cycle suits"))->SetEnabled(false);
			static_cast <BControl*> (FindView("cycle values"))->SetEnabled(false);
			static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"))->SetEnabled(false);
			static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"))->SetEnabled(false);

			current_rules->orderingtype = ORDERINGNONE;
			break;
		case IE_TRANSMISSIONRULEEDITOR_ORDERINGSENDER:	// 'Ordering - sender' is pressed...
			static_cast <BControl*> (FindView("cycle suits"))->SetEnabled(false);
			static_cast <BControl*> (FindView("cycle values"))->SetEnabled(false);
			static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"))->SetEnabled(false);
			static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"))->SetEnabled(false);

			current_rules->orderingtype = ORDERINGSEND;
			break;
		case IE_TRANSMISSIONRULEEDITOR_ORDERINGRECEIVER:	// 'Ordering - receiver' is pressed...
			static_cast <BControl*> (FindView("cycle suits"))->SetEnabled(false);
			static_cast <BControl*> (FindView("cycle values"))->SetEnabled(false);
			static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"))->SetEnabled(false);
			static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"))->SetEnabled(false);

			current_rules->orderingtype = ORDERINGRECV;
			break;

		case IE_TRANSMISSIONRULEEDITOR_ORDERINGSOME:	// 'Ordering - Some' is pressed...
			if (current_rules->ordering == NULL) current_rules->ordering = new order_props();
			
			static_cast <BControl*> (FindView("cycle suits"))->SetEnabled(true);
			static_cast <BControl*> (FindView("cycle values"))->SetEnabled(true);
			static_cast <BMenuField*> (FindView("Pile Ordering - Suit Steps"))->SetEnabled(true);
			static_cast <BMenuField*> (FindView("Pile Ordering - Value Steps"))->SetEnabled(true);
	//alter steppings			
			static_cast <BControl*> (FindView("cycle suits"))->SetValue(current_rules->ordering->cyclesuits);
			static_cast <BControl*> (FindView("cycle values"))->SetValue(current_rules->ordering->cyclevalues);

			current_rules->orderingtype = ORDERINGSOME;

			break;

		case IE_TRANSMISSIONRULEEDITOR_ORDERINGBLOCK:	// 'Ordering - Sticky' is pressed...
		{
			bool enablesnappable = static_cast <BControl*> (FindView("Ordering - Elastic"))->Value();
			static_cast <BControl*> (FindView("Ordering - Snappable"))->SetEnabled(enablesnappable);
			current_rules->behavior = BLOCK_DRAG; 			
			break;
		};
		case IE_TRANSMISSIONRULEEDITOR_ORDERINGUFCLEAN:	// 'Ordering - Elastic' is pressed...
		{
			bool enablesnappable = static_cast <BControl*> (FindView("Ordering - Elastic"))->Value();
			static_cast <BControl*> (FindView("Ordering - Snappable"))->SetEnabled(enablesnappable);
			current_rules->behavior = UF_CLEAN_DRAG; 			
			break;
		};
		case IE_TRANSMISSIONRULEEDITOR_ORDERINGUFMESSY:	// 'Ordering - Snappable' is pressed...
			current_rules->behavior = UF_MESSY_DRAG; 			
			break;

		case IE_TRANSMISSIONRULEEDITOR_CYCLESUITS:	// 'cycle suits' is pressed...
			current_rules->ordering->cyclesuits = (static_cast <BControl*> (FindView("cycle suits"))->Value()); 
			break;

		case IE_TRANSMISSIONRULEEDITOR_CYCLEVALUES:	// 'cycle values' is pressed...
			current_rules->ordering->cyclevalues = (static_cast <BControl*> (FindView("cycle values"))->Value()); 
			break;
		case TRANS_BOX_CHECKED:
		{
			BCheckBox* checkbox;
			int32 to, from;

			message->FindPointer("checkbox", (void**) &checkbox);
			message->RemoveName("checkbox");
			message->FindInt32("to", &to);
			message->FindInt32("from", &from);
			
			if (checkbox->Value())
			{
				targetrulest.push_back(to);
				targetrulesf.push_back(from);				
				message->what = RULES_REQUEST;
				target->MessageReceived(message);
			}
			else
			{
				vector<int32>::iterator itert = targetrulest.begin(), iterf = targetrulesf.begin();
				bool found = ((*itert == to) && (*iterf == from));
								
				while ( (iterf != targetrulesf.end()) && !found )
				{	
					iterf++;
					itert++;					
					found = ((*itert == to) && (*iterf == from));
				};
				if (found)
				{
					targetrulest.erase(itert);
					targetrulesf.erase(iterf);
				};
			};						
			break;
		};
		case IE_TRANSMISSIONRULEEDITOR_UPDATESYM:	// 'Sym' is pressed...
//may change this to an Update and make sym...		
			makesym = true;
		case IE_TRANSMISSIONRULEEDITOR_UPDATE:	// 'update' is pressed...
		{
			message->MakeEmpty();
			message->what = RULES_UPDATE;
			status_t errcode;
			vector <int32>::iterator itert = targetrulest.begin(), iterf = targetrulesf.begin();
			
			BMessage* rulemsg = current_rules->Encapsulate();
			errcode = message->AddMessage("rules", rulemsg);	
			message->AddBool("makesym", makesym);//makesym not used later
			message->AddInt32("to", 0);
			message->AddInt32("from", 0);

			while ((itert != targetrulest.end()) && (iterf != targetrulesf.end()))
			{
				message->ReplaceInt32("to", *itert++);
				message->ReplaceInt32("from", *iterf++);
				target->MessageReceived(message);
			};
			
			makesym = false;
			break;
		};	
		default:
			inherited::MessageReceived(message);
			break;
	}
}
